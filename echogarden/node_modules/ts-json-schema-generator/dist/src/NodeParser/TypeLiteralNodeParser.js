import ts from "typescript";
import { NeverType } from "../Type/NeverType.js";
import { ObjectProperty, ObjectType } from "../Type/ObjectType.js";
import { isNodeHidden } from "../Utils/isHidden.js";
import { getKey } from "../Utils/nodeKey.js";
export class TypeLiteralNodeParser {
    typeChecker;
    childNodeParser;
    additionalProperties;
    constructor(typeChecker, childNodeParser, additionalProperties) {
        this.typeChecker = typeChecker;
        this.childNodeParser = childNodeParser;
        this.additionalProperties = additionalProperties;
    }
    supportsNode(node) {
        return node.kind === ts.SyntaxKind.TypeLiteral;
    }
    createType(node, context, reference) {
        const id = this.getTypeId(node, context);
        if (reference) {
            reference.setId(id);
            reference.setName(id);
        }
        const properties = this.getProperties(node, context);
        if (properties === undefined) {
            return new NeverType();
        }
        return new ObjectType(id, [], properties, this.getAdditionalProperties(node, context));
    }
    getProperties(node, context) {
        let hasRequiredNever = false;
        const properties = node.members
            .filter((element) => ts.isPropertySignature(element) || ts.isMethodSignature(element))
            .filter((propertyNode) => !isNodeHidden(propertyNode))
            .map((propertyNode) => new ObjectProperty(this.getPropertyName(propertyNode.name), this.childNodeParser.createType(propertyNode.type, context), !propertyNode.questionToken))
            .filter((prop) => {
            const type = prop.getType();
            if (prop.isRequired() && type instanceof NeverType) {
                hasRequiredNever = true;
            }
            return !(type instanceof NeverType);
        });
        if (hasRequiredNever) {
            return undefined;
        }
        return properties;
    }
    getAdditionalProperties(node, context) {
        const indexSignature = node.members.find(ts.isIndexSignatureDeclaration);
        if (!indexSignature) {
            return this.additionalProperties;
        }
        return this.childNodeParser.createType(indexSignature.type, context) ?? this.additionalProperties;
    }
    getTypeId(node, context) {
        return `structure-${getKey(node, context)}`;
    }
    getPropertyName(propertyName) {
        if (propertyName.kind === ts.SyntaxKind.ComputedPropertyName) {
            const symbol = this.typeChecker.getSymbolAtLocation(propertyName);
            if (symbol) {
                return symbol.getName();
            }
        }
        try {
            return propertyName.getText();
        }
        catch {
            return propertyName.escapedText;
        }
    }
}
//# sourceMappingURL=TypeLiteralNodeParser.js.map