import ts from "typescript";
import { LogicError } from "../Error/LogicError.js";
import { LiteralType } from "../Type/LiteralType.js";
import { NeverType } from "../Type/NeverType.js";
import { NumberType } from "../Type/NumberType.js";
import { ReferenceType } from "../Type/ReferenceType.js";
import { StringType } from "../Type/StringType.js";
import { TupleType } from "../Type/TupleType.js";
import { UnionType } from "../Type/UnionType.js";
import { derefType } from "../Utils/derefType.js";
import { getTypeByKey } from "../Utils/typeKeys.js";
export class IndexedAccessTypeNodeParser {
    typeChecker;
    childNodeParser;
    constructor(typeChecker, childNodeParser) {
        this.typeChecker = typeChecker;
        this.childNodeParser = childNodeParser;
    }
    supportsNode(node) {
        return node.kind === ts.SyntaxKind.IndexedAccessType;
    }
    createIndexedType(objectType, context, indexType) {
        if (ts.isTypeReferenceNode(objectType) && indexType instanceof LiteralType) {
            const declaration = this.typeChecker.getSymbolAtLocation(objectType.typeName)?.declarations?.[0];
            if (!declaration || !ts.isTypeAliasDeclaration(declaration) || !ts.isTypeLiteralNode(declaration.type)) {
                return undefined;
            }
            const member = declaration.type.members.find((m) => ts.isPropertySignature(m) &&
                Boolean(m.type) &&
                ts.isIdentifier(m.name) &&
                m.name.text === indexType.getValue());
            return member && this.childNodeParser.createType(member.type, context);
        }
        return undefined;
    }
    createType(node, context) {
        const indexType = derefType(this.childNodeParser.createType(node.indexType, context));
        const indexedType = this.createIndexedType(node.objectType, context, indexType);
        if (indexedType) {
            return indexedType;
        }
        const objectType = derefType(this.childNodeParser.createType(node.objectType, context));
        if (objectType instanceof NeverType || indexType instanceof NeverType) {
            return new NeverType();
        }
        const indexTypes = indexType instanceof UnionType ? indexType.getTypes() : [indexType];
        const propertyTypes = indexTypes.map((type) => {
            if (!(type instanceof LiteralType || type instanceof StringType || type instanceof NumberType)) {
                throw new LogicError(`Unexpected type "${type.getId()}" (expected "LiteralType.js" or "StringType.js" or "NumberType.js")`);
            }
            const propertyType = getTypeByKey(objectType, type);
            if (!propertyType) {
                if (type instanceof NumberType && objectType instanceof TupleType) {
                    return new UnionType(objectType.getTypes());
                }
                else if (type instanceof LiteralType) {
                    if (objectType instanceof ReferenceType) {
                        return objectType;
                    }
                    throw new LogicError(`Invalid index "${type.getValue()}" in type "${objectType.getId()}"`);
                }
                else {
                    throw new LogicError(`No additional properties in type "${objectType.getId()}"`);
                }
            }
            return propertyType;
        });
        return propertyTypes.length === 1 ? propertyTypes[0] : new UnionType(propertyTypes);
    }
}
//# sourceMappingURL=IndexedAccessTypeNodeParser.js.map