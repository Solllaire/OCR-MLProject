import ts from "typescript";
import { EnumType } from "../Type/EnumType.js";
import { isNodeHidden } from "../Utils/isHidden.js";
import { getKey } from "../Utils/nodeKey.js";
export class EnumNodeParser {
    typeChecker;
    constructor(typeChecker) {
        this.typeChecker = typeChecker;
    }
    supportsNode(node) {
        return node.kind === ts.SyntaxKind.EnumDeclaration || node.kind === ts.SyntaxKind.EnumMember;
    }
    createType(node, context) {
        const members = node.kind === ts.SyntaxKind.EnumDeclaration ? node.members.slice() : [node];
        return new EnumType(`enum-${getKey(node, context)}`, members
            .filter((member) => !isNodeHidden(member))
            .map((member, index) => this.getMemberValue(member, index)));
    }
    getMemberValue(member, index) {
        const constantValue = this.typeChecker.getConstantValue(member);
        if (constantValue !== undefined) {
            return constantValue;
        }
        const initializer = member.initializer;
        if (!initializer) {
            return index;
        }
        else if (initializer.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral) {
            return member.name.getText();
        }
        else {
            return this.parseInitializer(initializer);
        }
    }
    parseInitializer(initializer) {
        if (initializer.kind === ts.SyntaxKind.TrueKeyword) {
            return true;
        }
        else if (initializer.kind === ts.SyntaxKind.FalseKeyword) {
            return false;
        }
        else if (initializer.kind === ts.SyntaxKind.NullKeyword) {
            return null;
        }
        else if (initializer.kind === ts.SyntaxKind.StringLiteral) {
            return initializer.text;
        }
        else if (initializer.kind === ts.SyntaxKind.ParenthesizedExpression) {
            return this.parseInitializer(initializer.expression);
        }
        else if (initializer.kind === ts.SyntaxKind.AsExpression) {
            return this.parseInitializer(initializer.expression);
        }
        else if (initializer.kind === ts.SyntaxKind.TypeAssertionExpression) {
            return this.parseInitializer(initializer.expression);
        }
        else {
            return initializer.getText();
        }
    }
}
//# sourceMappingURL=EnumNodeParser.js.map