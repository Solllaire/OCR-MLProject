import ts from "typescript";
import { LiteralType } from "../Type/LiteralType.js";
import { UnionType } from "../Type/UnionType.js";
import assert from "../Utils/assert.js";
import { extractLiterals } from "../Utils/extractLiterals.js";
export const intrinsicMethods = {
    Uppercase: (v) => v.toUpperCase(),
    Lowercase: (v) => v.toLowerCase(),
    Capitalize: (v) => v[0].toUpperCase() + v.slice(1),
    Uncapitalize: (v) => v[0].toLowerCase() + v.slice(1),
};
export class IntrinsicNodeParser {
    supportsNode(node) {
        return node.kind === ts.SyntaxKind.IntrinsicKeyword;
    }
    createType(node, context) {
        const methodName = getParentName(node);
        const method = intrinsicMethods[methodName];
        assert(method, `Unknown intrinsic method: ${methodName}`);
        const literals = extractLiterals(context.getArguments()[0])
            .map(method)
            .map((literal) => new LiteralType(literal));
        if (literals.length === 1) {
            return literals[0];
        }
        return new UnionType(literals);
    }
}
function getParentName(node) {
    const parent = node.parent;
    assert(ts.isTypeAliasDeclaration(parent), "Only intrinsics part of a TypeAliasDeclaration are supported.");
    return parent.name.text;
}
//# sourceMappingURL=IntrinsicNodeParser.js.map