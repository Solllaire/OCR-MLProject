import ts from "typescript";
import { Context } from "../NodeParser.js";
import { AliasType } from "../Type/AliasType.js";
import { DefinitionType } from "../Type/DefinitionType.js";
import { getKey } from "../Utils/nodeKey.js";
export class PromiseNodeParser {
    typeChecker;
    childNodeParser;
    constructor(typeChecker, childNodeParser) {
        this.typeChecker = typeChecker;
        this.childNodeParser = childNodeParser;
    }
    supportsNode(node) {
        if (!ts.isInterfaceDeclaration(node) &&
            !ts.isClassDeclaration(node) &&
            !ts.isExpressionWithTypeArguments(node) &&
            !ts.isTypeAliasDeclaration(node)) {
            return false;
        }
        const type = this.typeChecker.getTypeAtLocation(node);
        const awaitedType = this.typeChecker.getAwaitedType(type);
        if (!awaitedType) {
            return false;
        }
        if (awaitedType === type) {
            return false;
        }
        return (!this.typeChecker.isTypeAssignableTo(type, awaitedType) &&
            !this.typeChecker.isTypeAssignableTo(awaitedType, type));
    }
    createType(node, context) {
        const type = this.typeChecker.getTypeAtLocation(node);
        const awaitedType = this.typeChecker.getAwaitedType(type);
        const awaitedNode = this.typeChecker.typeToTypeNode(awaitedType, undefined, ts.NodeBuilderFlags.IgnoreErrors);
        if (!awaitedNode) {
            throw new Error(`Could not find awaited node for type ${node.pos === -1 ? "<unresolved>" : node.getText()}`);
        }
        const baseNode = this.childNodeParser.createType(awaitedNode, new Context(node));
        const name = this.getNodeName(node);
        if (!name) {
            return baseNode;
        }
        return new DefinitionType(name, new AliasType(`promise-${getKey(node, context)}`, baseNode));
    }
    getNodeName(node) {
        if (ts.isExpressionWithTypeArguments(node)) {
            if (!ts.isHeritageClause(node.parent)) {
                throw new Error("Expected ExpressionWithTypeArguments to have a HeritageClause parent");
            }
            return node.parent.parent.name?.getText();
        }
        return node.name?.getText();
    }
}
//# sourceMappingURL=PromiseNodeParser.js.map