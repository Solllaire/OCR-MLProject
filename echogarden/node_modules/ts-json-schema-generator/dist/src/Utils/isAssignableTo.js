import { AnyType } from "../Type/AnyType.js";
import { ArrayType } from "../Type/ArrayType.js";
import { EnumType } from "../Type/EnumType.js";
import { IntersectionType } from "../Type/IntersectionType.js";
import { NullType } from "../Type/NullType.js";
import { ObjectType } from "../Type/ObjectType.js";
import { OptionalType } from "../Type/OptionalType.js";
import { TupleType } from "../Type/TupleType.js";
import { UndefinedType } from "../Type/UndefinedType.js";
import { UnionType } from "../Type/UnionType.js";
import { UnknownType } from "../Type/UnknownType.js";
import { VoidType } from "../Type/VoidType.js";
import { derefType } from "./derefType.js";
import { LiteralType } from "../Type/LiteralType.js";
import { StringType } from "../Type/StringType.js";
import { NumberType } from "../Type/NumberType.js";
import { BooleanType } from "../Type/BooleanType.js";
import { InferType } from "../Type/InferType.js";
import { RestType } from "../Type/RestType.js";
import { NeverType } from "../Type/NeverType.js";
function combineIntersectingTypes(intersection) {
    const objectTypes = [];
    const combined = intersection.getTypes().filter((type) => {
        if (type instanceof ObjectType) {
            objectTypes.push(type);
        }
        else {
            return true;
        }
        return false;
    });
    if (objectTypes.length === 1) {
        combined.push(objectTypes[0]);
    }
    else if (objectTypes.length > 1) {
        combined.push(new ObjectType(`combined-objects-${intersection.getId()}`, objectTypes, [], false));
    }
    return combined;
}
function getObjectProperties(type) {
    type = derefType(type);
    const properties = [];
    if (type instanceof ObjectType) {
        properties.push(...type.getProperties());
        for (const baseType of type.getBaseTypes()) {
            properties.push(...getObjectProperties(baseType));
        }
    }
    return properties;
}
function getPrimitiveType(value) {
    switch (typeof value) {
        case "string":
            return new StringType();
        case "number":
            return new NumberType();
        case "boolean":
            return new BooleanType();
    }
}
export function isAssignableTo(target, source, inferMap = new Map(), insideTypes = new Set()) {
    source = derefType(source);
    target = derefType(target);
    if (source instanceof NeverType) {
        return true;
    }
    if (target instanceof NeverType) {
        return false;
    }
    if (target instanceof InferType) {
        const key = target.getName();
        const infer = inferMap.get(key);
        if (infer === undefined) {
            inferMap.set(key, source);
        }
        else {
            inferMap.set(key, new UnionType([infer, source]));
        }
        return true;
    }
    if (source.getId() === target.getId()) {
        return true;
    }
    if (insideTypes.has(source) || insideTypes.has(target)) {
        return true;
    }
    if (source instanceof AnyType || target instanceof AnyType) {
        return true;
    }
    if (target instanceof UnknownType) {
        return true;
    }
    if (target instanceof VoidType) {
        return source instanceof NullType || source instanceof UndefinedType;
    }
    if (source instanceof UnionType || source instanceof EnumType) {
        return source.getTypes().every((type) => isAssignableTo(target, type, inferMap, insideTypes));
    }
    if (source instanceof IntersectionType) {
        return combineIntersectingTypes(source).some((type) => isAssignableTo(target, type, inferMap, insideTypes));
    }
    if (target instanceof ArrayType) {
        const targetItemType = target.getItem();
        if (source instanceof ArrayType) {
            return isAssignableTo(targetItemType, source.getItem(), inferMap, insideTypes);
        }
        else if (source instanceof TupleType) {
            return isAssignableTo(targetItemType, new UnionType(source.getTypes()), inferMap, insideTypes);
        }
        else {
            return false;
        }
    }
    if (target instanceof UnionType || target instanceof EnumType) {
        return target.getTypes().some((type) => isAssignableTo(type, source, inferMap, insideTypes));
    }
    if (target instanceof IntersectionType) {
        return combineIntersectingTypes(target).every((type) => isAssignableTo(type, source, inferMap, insideTypes));
    }
    if (source instanceof LiteralType) {
        return isAssignableTo(target, getPrimitiveType(source.getValue()), inferMap);
    }
    if (target instanceof ObjectType) {
        if (target.getNonPrimitive() &&
            (source instanceof NumberType || source instanceof StringType || source instanceof BooleanType)) {
            return false;
        }
        const targetMembers = getObjectProperties(target);
        if (targetMembers.length === 0) {
            return !isAssignableTo(new UnionType([new UndefinedType(), new NullType()]), source, inferMap, insideTypes);
        }
        else if (source instanceof ObjectType) {
            const sourceMembers = getObjectProperties(source);
            const inCommon = targetMembers.some((targetMember) => sourceMembers.some((sourceMember) => targetMember.getName() === sourceMember.getName()));
            return (targetMembers.every((targetMember) => {
                const sourceMember = sourceMembers.find((member) => targetMember.getName() === member.getName());
                return sourceMember == null ? inCommon && !targetMember.isRequired() : true;
            }) &&
                sourceMembers.every((sourceMember) => {
                    const targetMember = targetMembers.find((member) => member.getName() === sourceMember.getName());
                    if (targetMember == null) {
                        return true;
                    }
                    return isAssignableTo(targetMember.getType(), sourceMember.getType(), inferMap, new Set(insideTypes).add(source).add(target));
                }));
        }
        const isArrayLikeType = source instanceof ArrayType || source instanceof TupleType;
        if (isArrayLikeType) {
            const lengthPropType = targetMembers
                .find((prop) => prop.getName() === "length" && prop.isRequired())
                ?.getType();
            if (source instanceof ArrayType) {
                return lengthPropType instanceof NumberType;
            }
            if (source instanceof TupleType) {
                if (lengthPropType instanceof LiteralType) {
                    const types = source.getTypes();
                    const lengthPropValue = lengthPropType.getValue();
                    return types.length === lengthPropValue;
                }
            }
        }
    }
    if (target instanceof TupleType) {
        if (source instanceof TupleType) {
            const sourceMembers = source.getTypes();
            const targetMembers = target.getTypes();
            return targetMembers.every((targetMember, i) => {
                const numTarget = targetMembers.length;
                const numSource = sourceMembers.length;
                if (i == numTarget - 1) {
                    if (numTarget <= numSource + 1) {
                        if (targetMember instanceof RestType) {
                            const remaining = [];
                            for (let j = i; j < numSource; j++) {
                                remaining.push(sourceMembers[j]);
                            }
                            return isAssignableTo(targetMember.getType(), new TupleType(remaining), inferMap, insideTypes);
                        }
                        else if (numTarget < numSource) {
                            return false;
                        }
                    }
                }
                const sourceMember = sourceMembers[i];
                if (targetMember instanceof OptionalType) {
                    if (sourceMember) {
                        return (isAssignableTo(targetMember, sourceMember, inferMap, insideTypes) ||
                            isAssignableTo(targetMember.getType(), sourceMember, inferMap, insideTypes));
                    }
                    else {
                        return true;
                    }
                }
                else {
                    if (sourceMember === undefined) {
                        return false;
                    }
                    return isAssignableTo(targetMember, sourceMember, inferMap, insideTypes);
                }
            });
        }
    }
    return false;
}
//# sourceMappingURL=isAssignableTo.js.map