import { uniqueArray } from "./uniqueArray.js";
import { deepMerge } from "./deepMerge.js";
import { derefType } from "./derefType.js";
export function getAllOfDefinitionReducer(childTypeFormatter) {
    return (definition, baseType) => {
        const other = childTypeFormatter.getDefinition(derefType(baseType));
        definition.properties = deepMerge(other.properties || {}, definition.properties || {});
        function additionalPropsDefinition(props) {
            return props !== undefined && props !== true;
        }
        if (additionalPropsDefinition(definition.additionalProperties) &&
            additionalPropsDefinition(other.additionalProperties)) {
            let additionalProps = [];
            let additionalTypes = [];
            const addAdditionalProps = (addProps) => {
                if (addProps) {
                    if (addProps.anyOf) {
                        for (const prop of addProps.anyOf) {
                            if (prop.type) {
                                additionalTypes = additionalTypes.concat(Array.isArray(prop.type) ? prop.type : [prop.type]);
                            }
                            else {
                                additionalProps.push(prop);
                            }
                        }
                    }
                    else if (addProps.type) {
                        additionalTypes = additionalTypes.concat(Array.isArray(addProps.type) ? addProps.type : [addProps.type]);
                    }
                    else {
                        additionalProps.push(addProps);
                    }
                }
            };
            addAdditionalProps(definition.additionalProperties);
            addAdditionalProps(other.additionalProperties);
            additionalTypes = uniqueArray(additionalTypes);
            additionalProps = uniqueArray(additionalProps);
            if (additionalTypes.length > 1) {
                additionalProps.push({
                    type: additionalTypes,
                });
            }
            else if (additionalTypes.length === 1) {
                additionalProps.push({
                    type: additionalTypes[0],
                });
            }
            if (additionalProps.length > 1) {
                definition.additionalProperties = {
                    anyOf: additionalProps,
                };
            }
            else if (additionalProps.length === 1) {
                if (Object.keys(additionalProps[0]).length === 0) {
                    delete definition.additionalProperties;
                }
                else {
                    definition.additionalProperties = additionalProps[0];
                }
            }
            else {
                definition.additionalProperties = false;
            }
        }
        if (other.required) {
            definition.required = uniqueArray((definition.required || []).concat(other.required)).sort();
        }
        if ((other.additionalProperties || other.additionalProperties === undefined) &&
            definition.additionalProperties == false) {
            delete definition.additionalProperties;
        }
        return definition;
    };
}
//# sourceMappingURL=allOfDefinition.js.map